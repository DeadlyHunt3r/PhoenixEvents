<recyclerItem>
  <containers>
    <container orderPosition="1" areaName="Standard">
      <paragraph orderPosition="0" areaName="Standard">
        <value name="column-count">1</value>
        <value name="column-width-1">100</value>
        <value name="column-width-unit-1">%</value>
        <column orderPosition="0" areaName="Standard">
          <value name="width">100</value>
          <value name="width-unit">%</value>
          <pageItem name="" activeBegin="01/01/0001 00:00:00" activeEnd="01/01/0001 00:00:00" alwaysBuild="False" areaName="Standard" isActive="True" objectID="ffeeddfc-42ac-4f02-a1fc-7c7f35458206" rssFlag="False" styleName="quelltext-(html)" editorType="None" orderPosition="1" itemTemplateName="standard">
            <excerpt>let board = []; let isGameOver = false; let dragging = false; let startX, startY; let currentMove = { x: 0, y: 0 }; const boardElement = document.getElementById('board'); const restartButton = document.getElementById('restart'); function initGame() { board = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], ]; isGameOver = false; spawnTile(); spawnTile(); renderBoard(); } function renderBoard() { boardElement.innerHTML = ''; for (let i = 0; i 0) { move('right'); } else { move('left'); } } else if (Math.abs(currentMove.y)</excerpt>
            <value name="Text">let board = [];
let isGameOver = false;
let dragging = false;
let startX, startY;
let currentMove = { x: 0, y: 0 };

const boardElement = document.getElementById('board');
const restartButton = document.getElementById('restart');

function initGame() {
  board = [
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
  ];
  isGameOver = false;
  spawnTile();
  spawnTile();
  renderBoard();
}

function renderBoard() {
  boardElement.innerHTML = '';
  for (let i = 0; i &lt; 4; i++) {
    for (let j = 0; j &lt; 4; j++) {
      const cellValue = board[i][j];
      const cell = document.createElement('div');
      cell.classList.add('cell');
      if (cellValue &gt; 0) {
        cell.textContent = cellValue;
        cell.classList.add(`cell-${cellValue}`);
      }
      cell.dataset.row = i;
      cell.dataset.col = j;
      boardElement.appendChild(cell);
    }
  }
}

function spawnTile() {
  if (isGameOver) return;

  const emptyCells = [];
  for (let i = 0; i &lt; 4; i++) {
    for (let j = 0; j &lt; 4; j++) {
      if (board[i][j] === 0) {
        emptyCells.push({ i, j });
      }
    }
  }

  if (emptyCells.length === 0) {
    isGameOver = true;
    alert('Spiel vorbei!');
    return;
  }

  const { i, j } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
  board[i][j] = Math.random() &gt; 0.1 ? 2 : 4;
  renderBoard();
}

function move(direction) {
  if (isGameOver) return;

  let moved = false;

  if (direction === 'up') {
    for (let col = 0; col &lt; 4; col++) {
      let stack = [];
      for (let row = 0; row &lt; 4; row++) {
        if (board[row][col] !== 0) {
          stack.push(board[row][col]);
        }
      }

      stack = combine(stack);
      for (let row = 0; row &lt; 4; row++) {
        board[row][col] = stack[row] || 0;
      }
      if (stack.length &gt; 0) moved = true;
    }
  } else if (direction === 'down') {
    for (let col = 0; col &lt; 4; col++) {
      let stack = [];
      for (let row = 3; row &gt;= 0; row--) {
        if (board[row][col] !== 0) {
          stack.push(board[row][col]);
        }
      }

      stack = combine(stack);
      for (let row = 3; row &gt;= 0; row--) {
        board[row][col] = stack[3 - row] || 0;
      }
      if (stack.length &gt; 0) moved = true;
    }
  } else if (direction === 'left') {
    for (let row = 0; row &lt; 4; row++) {
      let stack = [];
      for (let col = 0; col &lt; 4; col++) {
        if (board[row][col] !== 0) {
          stack.push(board[row][col]);
        }
      }

      stack = combine(stack);
      for (let col = 0; col &lt; 4; col++) {
        board[row][col] = stack[col] || 0;
      }
      if (stack.length &gt; 0) moved = true;
    }
  } else if (direction === 'right') {
    for (let row = 0; row &lt; 4; row++) {
      let stack = [];
      for (let col = 3; col &gt;= 0; col--) {
        if (board[row][col] !== 0) {
          stack.push(board[row][col]);
        }
      }

      stack = combine(stack);
      for (let col = 3; col &gt;= 0; col--) {
        board[row][col] = stack[3 - col] || 0;
      }
      if (stack.length &gt; 0) moved = true;
    }
  }

  if (moved) {
    spawnTile();
  }
}

function combine(stack) {
  let newStack = [];
  for (let i = 0; i &lt; stack.length; i++) {
    if (stack[i] === stack[i + 1]) {
      newStack.push(stack[i] * 2);
      i++;
    } else {
      newStack.push(stack[i]);
    }
  }
  return newStack;
}

function handleMouseMove(event) {
  if (dragging) {
    const deltaX = event.clientX - startX;
    const deltaY = event.clientY - startY;

    if (Math.abs(deltaX) &gt; Math.abs(deltaY)) {
      currentMove.x = deltaX;
      currentMove.y = 0;
    } else {
      currentMove.y = deltaY;
      currentMove.x = 0;
    }
  }
}

function handleMouseUp(event) {
  if (dragging) {
    if (Math.abs(currentMove.x) &gt; 50) {
      if (currentMove.x &gt; 0) {
        move('right');
      } else {
        move('left');
      }
    } else if (Math.abs(currentMove.y) &gt; 50) {
      if (currentMove.y &gt; 0) {
        move('down');
      } else {
        move('up');
      }
    }
    dragging = false;
    currentMove = { x: 0, y: 0 };
  }
}

function handleMouseDown(event) {
  dragging = true;
  startX = event.clientX;
  startY = event.clientY;
}

boardElement.addEventListener('mousedown', handleMouseDown);
boardElement.addEventListener('mousemove', handleMouseMove);
boardElement.addEventListener('mouseup', handleMouseUp);

restartButton.addEventListener('click', initGame);

initGame();
</value>
            <dynamicSettings>
              <value name="name-align" />
              <value name="name-color" />
              <value name="name-level">h2</value>
            </dynamicSettings>
          </pageItem>
        </column>
      </paragraph>
    </container>
  </containers>
</recyclerItem>